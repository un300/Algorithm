###### 2020-01-19

# 01_계수 정렬

> - 계수 정렬은 특정 조건이 부합될 때만 사용할 수 있지만, **매우 빠른 정렬 알고리즘** 이다.
> - 모든 데이터가 양의 정수이고 데이터의 개수가 N개, 최댓값이 K일때 계수 정렬은 `O(N+K)` 를 보장한다.
> - 계수 정렬은 원리가 간단하지만. **데이터의 크기 범위가 제한되어 정수 형태로 표현할 수  있을때** 만 사용할 수 있다.
>   - 예를들어, 데이터의 값이 무한한 범위를 가질 수 있는 실수형 데이터가 주어지는 경우 계수 정렬은 사용하기 어렵다.
>   - 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 **1,000,000** 을 넘지 않을 때, 효과적으로 사용할 수 있다.
>   - 다른 말로는 가장 큰 데이터와 가장 작은 데이터의 차이가 크다면 계수 정렬은 사용할 수 없다.
> - 계수 정렬은 앞서 다루었던 3가지 정렬 알고리즘처럼 직접 리스트(배열) 내의 원소 값을 비교하여 자리를 바꾸는 방식이 아니다.
>   - 계수 정렬은 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다는 특징이 있다.
>   - '이코테' P172~P173을 확인!



## 1. 계수 정렬 소스코드

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

count_list = [0] * len(array)

for element in array :
    count_list[element] += 1

for element, count in enumerate(count_list) :
    for _ in range(count) :
        print(element, end=' ')
```





## 2. 계수 정렬의 시간 복잡도

> - 데이터의 범위만 한정되어 있다면 `O(N+K)` 를 항상 만족하기에, **기수 정렬** 과 더불어 가장 빠른 정렬법이라 할 수 있다.
> - 보통 **기수 정렬** 은 **계수 정렬** 비해서 동작은 느리지만, 처리할 수 있는 정수의 크기는 더 크다. 하지만 **기수 정렬** 을 다루는 코딩 테스트 문제는 자주 거의 출제되지 않는다.



## 3. 계수 정렬의 시간 복잡도

> - 예를들어 데이터가 0과 999,999 단 2개만 존재한다고 가정해보자. 이럴 경우에도 리스트의 크기를 100만개가 되도록 선언해 주어야 한다.
> - 그러므로, 계수 정렬은 같은 숫자의 원소가 지속적으로 등장할때 효과적이다. (예를들어 성적)
> - 하지만 데이터의 특성을 파악하기 어렵다면, 퀵 정렬을 쓰는 것이 유리하다.
> - 다시말해 **계수 정렬** 은 데이터의 크기가 한정 되어있고, 동일한 숫자의 데이터가 중복되어 있을때 유리하다.
>   - 다만 일반적인 코딩테스트 시스템 환경에서는 메모리 공간상의 제약과 입출력 시간 문제로 인하여 입력되는 데이터의 개수를 1,000만개 이상으로 설정할 수 없는 경우가 많기 때문에, 정렬 문제에서의 데이터 개수는 1,000만 개 미만으로 출제될 것이다.