###### 2021-01-16

# 04_퀵 정렬

> ### 퀵 정렬은 지금까지 배운 정렬 알고리즘 중에서 가장 많이 사용되는 정렬 알고리즘이다.
>
> - 이책에서는 다루지 않는 병합 정렬과 함께 프로그래밍 언어에서 정렬 라이브러리의 근간이 되는 알고리즘이다.
> - **기준 데이터를 설정하고, 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸면 어떨까?**
> - 퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.
> - 이해하기 어렵지만, 병합 정렬, 힙 정렬 등 다른 고급 정렬 기법에 비해 쉽게 소스코드를 작성할 수 있다.
> - 퀵정렬에는 **피벗** 을 사용한다. **피벗** 이란, 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '기준'을 말한다.
>   - 퀵 정렬을 수행하기 전에는 **피벗** 을 어떻게 설정할 것인지 미리 명시해야 한다.
>   - 여기서는 가장 대표적인 분할 방식인 **호어 분할** 방식을 기준으로 퀵 정렬을 설명한다.



## 1. 호어 분할

> - **호어 분할** 은 다음과 같은 기준으로 분할한다.
>   1. 리스트에서 첫 번째 원소를 피벗으로 설정한다.
>   2. 리스트의 왼쪽에서 원소를 차례로 훓어 피벗보다 작은 데이터를 찾고, 반대로 리스트의 오른쪽에서 부터 원소를 차레로 훓어 피벗보다 큰 데이터를 찾는다.
>   3. 왼쪽에서 피벗보다 작은 데이터, 오른쪽에서 피벗보다 큰 데이터를 찾아 조건을 만족한다면, 두 원소의 자리를 바꾼다.
>   4. 왼쪽에서 훓는 것과 오른쪽에서 훓는 것이 서로 교차하는 지점에서, 피벗과 작은데이터의 자리를 바꾼다.
>   5. 그렇다면 피벗을 기준으로 피벗의 왼쪽에는 피벗보다 작은 데이터가, 오른편에는 피벗보다 큰 데이터가 존재한다.
>   6. 피벗을 기준으로 왼쪽과 오른쪽 각각에 1-4 과정을 반복한다.





## 2. 호어 분할에 기초한 퀵 정렬

- 파이썬의 장점을 살려 짧고 직관적으로 작성한 퀵 정렬 소스코드이다.
- 전통 퀵 정렬의 분할 방식과는 조금 다른데, 피벗과 리스트의 원소를 비교하는 비교 연산 횟수가 증가하므로 시간 면에서는 조금 비효율적이다.
- 하지만, 좀 더 직관적이고 이해하기 쉽다는 장점이 있다.

```python
def quick_sort(array) :
    if len(array) <= 1 :
        return array

    pivot_element = array[0]
    rest_array    = array[1:]

    left_array    = [ small_element for small_element in rest_array if small_element <= pivot_element ]
    right_array   = [ big_element for big_element in rest_array if big_element > pivot_element ]
    sorted_array  = quick_sort(left_array) + [pivot_element] + quick_sort(right_array)
    return sorted_array

a = [1, 0, 3, 4, 5, 6, 2, 7, 8, 9]

print(quick_sort(a))
```





## 3. 퀵 정렬의 시간 복잡도

> - 앞서 다룬 선택 정렬과 삽입 정렬의 시간 복잡도는 `O(N^2)` 이다. 
> - 선택 정렬과 삽입 정렬은 최악의 경우에도 항상 시간 복잡도가 `O(N^2)` 를 보장한다.
> - 퀵 정렬의 경우 평균 시간 복잡도는 `O(Nlog(N))` 이다. 앞서 다룬 두 정렬에 비해 매우 빠른편이다.
> - 퀵 정렬이 어떻게 평균적으로 `O(Nlog(N))` 의 시간 복잡도를 가지는지 궁금할 수 있는데, 퀵 정렬의 시간 복잡도에대한 증명은 코딩 테스트를 목적으로 하는 경우, 퀵 정렬의 시간 복잡도 증명에 대하여 자세히 알지 못해도 큰 무리는 없다.
> - 따라서 자세한 설명보다는 직관적인 이해를 돕는 목적으로 전개하고자 한다.
>   - ''이코테' p169를 참조하세요

| 데이터의 개수 (N) | N^2(선택 정렬, 삽입 정렬) | Nlog2N (퀵 정렬) |
| ----------------- | ------------------------- | ---------------- |
| N = 1,000         | 1,000,000                 | 10,000           |
| N = 10,000        | 1,000,000,000,000         | 20,000,000       |

> - 일반적으로 컴퓨터공학과 학부에서 퀵 정렬을 공부할 때에는 퀵 정렬의 수학적인 검증에 대해서도 공부하지만, 코딩 테스트를 준비하는 과정에서는 그림을 통한 직관적인 이해를 하는 것 만으로도 충분하다.
> - 다만, 퀵 정렬의 시간 복잡도에서 기억해야할 것이 하나있다.
>   - 평균적인 시간 복잡도는 `O(NlogN)` 이지만 **최악의 경우는 `O(N^2)`**라는 점이다.
>   - 파이썬의 기본 정렬 라이브러리는 `O(NlogN)` 을 보장해 주기 때문에 걱정하지 않아도 된다.

